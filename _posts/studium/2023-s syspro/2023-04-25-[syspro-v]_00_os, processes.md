---
layout: single # 새로운 포스트 작성시 확인할 것
title: "[syspro-v] 01 운영체제와 프로세스(OS and Processes)" #제목 확인
folder: "syspro" #폴더 확인
categories:
  - syspro #카테고리 확인

tags: [blog, syspro] #태그 확인

author_profile: true
sidebar:
  nav: "sidebar-category"

toc: true
toc_label: "list"
toc_icon: "bars"
toc_sticky: true
classes: wide

lang: ko
lang-ref: multilingual

# use_math: true                    #숫자 사용 확인

date: 2023-04-25 #날짜 확인
---

<div class="notice--info">
“Während ich studiere, schreibe ich hier kurze Zusammenfassungen für eine längere Erinnerung.”<br>
"공부하면서 더 오래 상기시키기 위해 여기에 짧은 요약을 씁니다."<br>

<pre>
OS    : Window
Editor: VScode</pre>
</div>

# 00 운영체제 (OS, BS_Betriebssystem)

**운영체제에 대한 간단 설명(한국어):** [컴퓨터가 3층집?](https://www.youtube.com/watch?v=M9ZrQX1UgAU)

운영 체제(Operating System, OS)는 컴퓨터 하드웨어와 사용자 프로그램 간의 중개자 역할을 하는 소프트웨어다. OS는 컴퓨터 시스템에서 여러 가지 기능을 수행한다. 이러한 기능에는 하드웨어와 프로그램의 추상화, 자원 관리, 프로세스 스케줄링, 파일 관리, 네트워킹, 보안 등이 있다.

운영 체제는 다음과 같은 기능을 수행한다.

**추상화:** 운영 체제는 하드웨어 자원을 프로그램이 사용할 수 있는 추상화된 형태로 제공한다. 이를 통해 프로그래머는 하드웨어의 복잡성과 다양성을 신경 쓰지 않고도 프로그램을 작성할 수 있다.

**자원 관리 (Betriebsmittelverwaltung, resource management):** 운영 체제는 시스템의 자원을 효율적으로 관리한다. 이는 CPU, 메모리, 디스크 등 다양한 자원을 할당하고 관리하면서 시스템 성능을 최적화한다.

**스케줄링 (Auftragsteuerung, Scheduling):** 운영 체제는 다수의 프로세스를 동시에 실행하면서 CPU 자원을 효율적으로 사용하기 위해 스케줄링을 수행한다.

**파일 관리 (Dateiverwaltung, file management):** 운영 체제는 파일 시스템을 통해 파일을 생성, 수정, 삭제하고, 저장 장치에 대한 접근을 관리한다.

**보안 또는 신뢰성 (Zuverlässigkeit, reliability):** 운영 체제는 시스템의 안전을 보장하기 위해 사용자 인증, 암호화, 권한 제어 등의 보안 기능을 제공한다.

**인터럽트 처리 (Urbrechungsverarbeitung Interrupt Handling):**  
인터럽트 처리는 말 그대로 운영 체제가 하드웨어 장치에서 발생하는 인터럽트를 처리하는 기능이다. 인터럽트는 하드웨어에서 발생하는 이벤트로, 예를 들어 키보드나 마우스 입력, 디스크나 네트워크 작업 등이 있다. 운영 체제는 이러한 인터럽트를 처리하고, 해당 이벤트에 대한 작업을 수행한다.

**프로세스 전환 (Prozessumschaltung):**  
은 운영 체제가 CPU를 사용하는 프로세스를 변경하는 기능이다. 여러 개의 프로세스가 동시에 실행되는 경우, CPU를 각각의 프로세스에 할당하면서 프로세스 간에 전환이 일어난다. 이때 운영 체제는 CPU 할당을 조정하고, 프로세스 간의 전환이 원활하게 이루어지도록 한다.

**프로그램 할당 (Programmallokation program allocation):**  
프로그램 할당은 운영 체제가 메모리 상의 자원을 프로그램에 할당하는 기능이다. 운영 체제는 프로그램을 실행할 때, 필요한 메모리 자원을 할당하고, 이를 사용할 수 있도록 한다. 이때 운영 체제는 메모리를 효율적으로 사용하기 위해 메모리 단편화 등의 문제를 고려한다.

결론적으로 운영 체제는 사용자가 하드웨어와 프로그램을 쉽게 사용할 수 있도록 도와준다다.

# 01 매커니즘과 정책(방법)(Mechanismen und Methoden (Policies))

**매커니즘(Mechanism):**  
운영체제에서 **매커니즘(Mechanism)**은 **시스템의 동작을 구현하는 데 사용되는 절차나 방법**을 말한다. 즉, 매커니즘은 시스템 내부에서 어떻게 동작하는지에 대한 규칙이나 방법을 정하는 것이다.  
(예를 들어, CPU 스케줄링에 대한 매커니즘은 우선순위, 라운드 로빈, FCFS 등 다양한 방법이 있다.)

**정책(Policy):**  
반면에 **정책(Policy)**은 매커니즘을 이용하여 **실제로 동작하는 방식을 결정**하는 것입니다. 정책은 사용자나 시스템 운영자가 **시스템에게 명시한 목표나 요구사항에 따라 다르다.**  
(예를 들어, CPU 스케줄링의 경우, 각 프로세스에 CPU 할당 시간을 얼마나 주는지, 우선순위를 어떻게 부여하는지, 멀티태스킹에서 동시에 실행되는 프로세스 수 등의 정책이 있다.)

**매커니즘과 정책은 분리되어 있어야 한다.** 매커니즘은 변경될 가능성이 적고 일반적으로 적용될 수 있는 규칙을 제공하고, 정책은 시스템을 다른 목적에 맞게 구성하고 변화에 대처할 수 있도록 제공된다. 따라서 매커니즘은 정책이 변경되어도 변경될 필요가 없다.

(예를 들어, 우선순위 기반 CPU 스케줄링의 매커니즘은 우선순위 값에 따라 프로세스를 선택하고 실행한다. 그리고서 실행 할 때, 정책으로는 우선순위 값을 어떻게 설정할지, 어떤 프로세스에 더 많은 우선순위를 부여할지, CPU 할당 시간을 어떻게 설정할지 등이 있다.)

---

# 02 사용자 모드와 시스템 모드(Benutzermodus und Systemmodus)

**보안상의 이유**로 CPU와 운영 체제의 두 가지 상태 또는 모드(프로세서 상태 레지스터의 비트) 간의 구분이 이루어진다.

| `사용자모드`                     | `시스템모드`            |
| -------------------------------- | ----------------------- |
| 비권한 상태                      | 특권 상태               |
| 일부 지침 차단                   | 허용되는 모든 지침      |
| 일부 레지스터에 액세스할 수 없음 | 모든 레지스터 사용 가능 |
| 일반적으로 사용자 프로그램용     | 일반적으로 운영 체제용  |

<div class="notice--info">
<h4>사용자 모드:</h4>
사용자 모드는 비프로그래머가 실행하는 일반적인 프로그램이 동작할 때의 모드다. <br>
이 모드에서는 사용자 프로그램이 시스템 리소스에 직접적인 접근을 할 수 없고, 제한된 명령어와 레지스터만 접근이 가능하다.<br>
<br>
<h4>시스템 모드:</h4>
시스템 모드는 운영체제가 실행되는 모드다. <br>
이 모드에서는 운영체제가 모든 하드웨어와 소프트웨어 리소스에 직접적인 접근을 할 수 있으며, 모든 명령어와 레지스터에 대한 접근이 가능하다. <br>
이는 운영체제가 시스템 전체를 관리하고, 사용자 프로그램들을 감독하고, 시스템의 안전성과 보안을 유지하기 위해 필요하다.
</div>

**사용자 모드에서 시스템 모드로 전환되는 경우**는, 예를 들어 하드웨어 인터럽트가 발생하는 경우 또는 프로그램이 금지된 명령을 수행하려고 시도하는 경우다.  
**시스템 모드에서 사용자 모드로 전환되는 경우**는, 시스템 호출이 완료되면 발생한다. 이 경우 운영체제는 인터럽트를 사용하여 프로그램의 실행을 다시 시작한다.

<img src="https://velog.velcdn.com/images%2Fyanghl98%2Fpost%2F3fe1b842-a2e9-4056-b266-f9c034226bd5%2Fimage.png" width="700px"/>

## 02-1 시스템 콜 (Systemaufruf, System call)

운영체제는 시스템 콜 인터페이스를 통해 기능을 제공한다.일반 응용 프로그램이 동작하는 비특권 모드인 사용자 모드에서 시스템의 자원이나 하드웨어를 직접적으로 컨트롤 할 수 없으며 이를 하기 위해서는 System call(시스템 콜)을 사용해야 한다.

프로세스 6단계는 다음과 같다.

1. 프로세스의 상태는 "실행 대기" 상태이며, 사용자 프로그램이 실행되고 있다.
2. 사용자 프로그램이 시스템 콜을 호출한다.
3. 호출된 시스템 콜은 CPU를 사용자 모드에서 커널 모드로 전환시킨다.
4. 시스템 콜의 인자를 검사하고 해당 기능을 수행한다.
5. 기능이 완료되면, 커널 모드에서 사용자 모드로 다시 전환하고 시스템 콜의 결과를 반환한다.
6. 프로세스의 상태는 다시 "실행 대기" 상태가 되며, 사용자 프로그램이 계속 실행된다.

## 02-2 인터럽트(Unterbrechungen, Interrupts)

인터럽트는 CPU가 어떤 작업을 수행하다가 중단되었음을 알리는 신호다.

### 02-2-1 인터럽트 프로세스

버스(컴퓨터에서 데이터, 명령어, 주소 등을 전송하기 위한 통신 경로)에는 적어도 하나의 인터럽션 라인이 있다.

1. CPU 명령어가 실행될 때마다 인터럽션 신호가 있는지 확인한다.
2. 만약 있다면 즉시 인터럽션을 처리하기 위한 프로시저로 점프한다.
3. 인터럽션의 평가 결과에 따라 필요한 작업이 수행/진행된다.
4. 그리고 실행 하던 작업으로 돌아간다.

### 02-2-2 내부/외부 인터럽트

인터럽트는 내부와 외부로 나눌 수 있다.

외부 인터럽트:

하드웨어적인 이유로 발생하며, 입출력 장치나 타이머 등 외부적인 요소로부터 발생한다.  
외부 인터럽트는 운영체제에서 처리해야 한다.  
발생 시점을 예측할 수 없다.
예) 입출력 장치, 타이밍 자치, 전원 등 외부적 요인에 의해 발생

내부 인터럽트:
내부 인터럽트는 프로그램의 실행 과정에서 발생하며, 소프트웨어적인 이유로 인해 발생한다.
내부 인터럽트는 프로그램에서 직접 처리할 수 있다.
발생 시점이 예측 가능하다.
예) 0으로 나누기 / Underflow / Overflow / Exception

### 02-2-3 인터럽트 처리 루틴

1. Interrupt 발생: 하드웨어 장치나 프로그램 내에서 Interrupt가 발생합니다.
2. Interrupt 루틴 호출: CPU는 현재 실행중인 프로그램을 일시 중지하고 Interrupt 루틴을 호출합니다.
3. 현재 상태 저장: 현재 실행중인 프로그램의 상태가 저장됩니다.
4. Interrupt 루틴 실행: Interrupt 루틴이 실행됩니다. 이 루틴은 Interrupt가 발생한 원인을 확인하고 적절한 작업을 수행합니다.
5. 이전 상태 복원: Interrupt 루틴이 실행을 완료하면, 이전에 저장된 상태가 복원됩니다.
6. 현재 실행 중인 프로그램으로 복귀: CPU는 현재 실행중인 프로그램으로 제어를 반환합니다.

### 02-2-4 인터럽트 불능 상태(Interrupt Disable)

인터럽트 처리 과정에서 다른 인터럽트가 발생하면 처리 과정이 중단되어 원하지 않는 동작을 유발할 수 있다. 따라서 인터럽트 처리 중에는 다른 인터럽트를 받지 않도록 하는 인터럽트 불능 상태(Interrupt Disable)로 만들어야 한다. 이를 통해 인터럽트 처리의 일관성과 안정성을 유지할 수 있다.

인터럽트 불능 상태를 설정하는 방법 중 하나는 인터럽트 **마스킹(Masking)**이다. 인터럽트 마스킹은 처리 중인 인터럽트를 제외한 다른 인터럽트를 불능 상태로 만드는 것이다.

### 02-2-5 중첩된 인터럽트 처리방법

인터럽트를 우선순위로 정렬하고 우선순위가 높은 순으로 처리한다.

# 03 프로세스(Prozesse)

프로세스는 시스템에서 실행되는 활동을 나타내는 동적인 객체이며 시스템 및 응용 소프트웨어에서 기능적이고 구조화된 단위이다. 프로세스는 특정 프로그램을 실행하기 위해 특화된 가상 머신이며, 프로그램의 인스턴스 또는 **실행 중인 프로그램**을 나타낸다. 프로세스는 운영 체제에서 관리되며, 각각 고유한 식별자, **주소 공간(필요한 경우 추가 리소스 소유)**, **실행 상태(하나 이상의 스레드)** 및 자원 할당을 가지고 있다.

## 03-1 주소 공간(Adressräume)

주소공간이란 프로세스에서 메모리를 사용할 때 할당되는 공간을 의미한다. 모든 프로세스는 주소공간을 가지며, 이는 프로세스에서 사용할 수 있는 물리적 메모리의 크기를 결정한다. 각 프로세스는 자신의 주소공간에만 접근할 수 있으며, 한 프로세스는 다른 프로세스의 주소공간에 직접 접근할 수 없다.

주소공간은 두 가지 유형으로 나뉘는데, **물리적 주소공간**과 **가상 주소공간**이다.

**물리적 주소공간**은 시스템에 있는 실제 메모리(RAM, 레지스터 등)를 나타내며,**가상 주소공간**은 프로세스가 사용하는 가상 메모리를 나타낸다. 각 프로세스는 가상 주소공간을 가지며, 이를 사용하여 물리적 메모리에 접근합니다. 이를 통해 한 프로세스가 다른 프로세스의 메모리를 손상시키지 않고 안전하게 실행될 수 있다.

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/32/Virtual_address_space_and_physical_address_space_relationship.svg/1024px-Virtual_address_space_and_physical_address_space_relationship.svg.png" width="600px"/>

이미지 출처: [위키백과](https://ko.wikipedia.org/wiki/%EB%AC%BC%EB%A6%AC_%EC%A3%BC%EC%86%8C)

### 03-1-1 물리적 주소공간(Physischer Adressraum)

<img src="https://github.com/Sehoon1207/sehoon1207.github.io/blob/main/_posts/studium/2023-s%20syspro/imgs/01_Physischer%20Adressraum-100.jpg?raw=true" width="600px"/>

물리적 주소공간은 시스템의 하드웨어 컴포넌트(램, 레지스터, 컨트롤러 등)과 주변기기가 저장되는 주소 공간이다. 이러한 하드웨어 구성 요소들은 CPU가 직접 액세스할 수 있으며 또한 각각의 물리적 주소를 가지고 있다. 그리고 그 주소들은 시스템에서 고유하게 할당된다. 이렇게 할당된 주소들을 사용하여 프로세스가 하드웨어 컴포넌트와 상호작용할 수 있게 된다. 또한, 시스템은 물리적 주소 공간을 사용하여 장치 드라이버와 같은 하드웨어와 관련된 다른 소프트웨어 구성 요소들도 로드할 수 있다.

### 03-1-2 가상 주소공간(Virtueller Adressraum)

<img src="https://github.com/Sehoon1207/sehoon1207.github.io/blob/main/_posts/studium/2023-s%20syspro/imgs/01_Virtueller%20Adressraum-100.jpg?raw=true" width="600px"/>

가상 주소공간은 프로세스가 사용할 수 있는 메모리 공간을 추상화한 것이다. 가상 주소공간은 프로세스의 `프로그램 코드`, `정적 데이터`(전역 변수, 정적 수정자가 있는 지역 변수), `힙(heap)`, `스택(stack)` 등을 포함한다.

<div class="notice--info">
1. <b>프로그램 코드</b>는 주소 공간의 한 부분으로서, 프로세스가 실행할 명령어의 모음이다.<br>  
2. <b>정적 데이터</b>는 전역 변수와 같은 프로그램 실행 중에 고정되어 있는 데이터를 나타낸다.<br>  
3. <b>동적 데이터인 힙(heap)</b>은 실행 중에 메모리 할당을 받는 데이터다. 힙은 실행 중에 크기가 동적으로 변할 수 있으며, 일반적으로 수동으로 할당 및 해제된다.<br>  
4. 마지막으로, <b>동적 데이터인 스택(stack)</b>은 프로세스의 호출 스택(call stack)을 포함하며, 함수 호출과 반환과 같은 런타임 동작을 처리한다. 스택은 자동으로 할당 및 해제된다.<br>
</div>

## 03-2 프로세스와 프로그램

가상 주소공간은 각각의 프로세스에게 할당되며, 각 프로세스는 해당 주소공간을 독립적으로 사용한다.  
즉, 각 프로세스는 자신만의 가상 주소공간을 가지고 있으며, 해당 공간 안에서 자신의 프로그램 코드, 데이터 및 스택 등을 관리하는 것이다.  
예를 들어, 하나의 프로그램이 두 개의 프로세스에서 실행될 경우, 각각의 프로세스는 서로 다른 가상 주소공간을 가지게 된다. 따라서, 두 프로세스가 동시에 같은 코드를 실행하더라도, 각각의 프로세스는 서로 다른 메모리 공간에서 실행되는 것이다.

### 03-2-1 프로세스의 실행(Ausführung von Prozessen)

<img src="https://github.com/Sehoon1207/sehoon1207.github.io/blob/main/_posts/studium/2023-s%20syspro/imgs/01_Ausf%C3%BChrung%20von%20Prozessen-100.jpg?raw=true" width="1000px"/>

프로세스 실행은 다음과 같은 방식으로 이루어진다. 앞서 이야기 했듯이, 각 프로세스는 자신만의 가상 주소 공간을 가지고 있으며, 이 가상 주소 공간 안에는 코드, 데이터 등이 저장되어 있다. 프로세스는 CPU와 메모리 등의 시스템 자원을 필요로 하며, 운영체제는 이러한 자원을 할당하고 관리한다.

일반적으로, 프로세스는 다른 프로세스와 동시에 실행될 수 있다. 운영체제는 여러 개의 프로세스를 번갈아 가며 실행하는데, 이를 시분할 방식이라고 한다. 이 방식은 각 프로세스가 CPU를 공정하게 사용할 수 있도록 하며, 여러 프로세스가 동시에 실행되는 것처럼 보이게 한다.

하지만, 프로세스가 CPU에서 실행되는 동안 I/O 작업 등으로 인해 대기해야 하는 경우, CPU는 다른 프로세스에게 할당됩니다. 이를 **비선점(preemptive) 방식**이라고 한다. 반면, 프로세스가 CPU를 계속해서 점유하면서 다른 프로세스의 실행을 방해하지 않는 것을 **선점(preemptive) 방식**이라고 한다.

또한, 프로세스는 **배치 처리(batch processing) 방식**으로 실행될 수도 있다. 이는 여러 개의 프로세스를 순차적으로 실행하는 방식으로, 한 번에 많은 양의 작업을 처리할 수 있다. 그러나 I/O 작업 등으로 인해 CPU가 대기해야 하는 경우, 다음 프로세스가 실행되지 않아 효율적이지 않다.

**다중프로그래밍(Multiprogrammierung)**은 여러 개의 프로세스가 동시에 실행될 수 있는 기능이다. 이를 통해 CPU 활용도를 최대화하고, 프로세스 간 대기 시간을 줄일 수 있다.

기존의 단일 프로그램 처리 방식에서는 하나의 프로세스가 끝나야 다음 프로세스가 시작될 수 있었지만, Multiprogrammierung에서는 여러 프로세스가 동시에 메모리에 적재되고, CPU를 할당받아 번갈아가며 실행된다. 이를 가능하게 하는 기술적인 요소로는 **시분할 시스템, 다중 프로그래밍, 멀티 태스킹** 등이 있다.

### 03-2-2 다중프로그래밍의 모델링

다중 프로그래밍의 모델링은 얼마나 많은 프로세스가 시스템에 로드되어야 하는지 결정하는 것이다. 이에 대한 정확한 답은 없지만, 몇 가지 가정을 기반으로 추정할 수 있다.

ex) 한 프로세스는 E/A 작업을 기다리는 시간의 비율 p을 가지고 있다. 만약 n개의 프로세스가 E/A 작업이 끝나기를 기다리고 있다면, 동시에 대기 중인 프로세스의 수는 $$p^n$$이다. CPU의 활용도 $$A = 1 - p^n$$으로 계산할 수 있다. 따라서, 시스템이 적절하게 다중 프로그래밍되었다면, CPU의 대부분은 활동 상태에 있으므로 A는 높아진다.  
일반적으로 n은 **다중 프로그래밍의 차수(Degree of Multiprogramming)**라고 불리며, 시스템에 로드되는 프로세스 수를 결정하는 데 중요한 역할을 한다.

### 03-2-3 프로세스상태(Prozesszustände)

현재 상태에 따라 프로세스는 다양한 상태에 위치할 수 있다.

**실행(Running):** 프로세스가 물리적인 프로세서를 점유하고 있으며 현재 실행 중인 상태.
**준비(Ready):** 프로세스는 모든 필요한 자원을 가지고 있으며 프로세서 할당을 기다리고 있는 상태.
**차단, 대기(Waiting):** 프로세스는 조건 충족을 기다리는 상태.
**종료(Terminated):** 프로세스가 모든 계산을 완료하고 할당 된 자원을 해제한 상태.

---

Quelle(text):  
pdf dateien, [studocu](https://www.studocu.com/de/course/technische-universitat-berlin/systemprogrammierung/1514199)  
pdf dateien, [studydrive](https://www.studydrive.net/de/course/systemprogrammierung/137292#documents)  
Klausur pdf dateien, [Klausurensammlung der Freitagsrunde](https://docs.freitagsrunde.org/Klausuren/Systemprogrammierung/)  
Vorlesung, Systemprogrammierung, [TU-Berlin]<https://www.tu.berlin/dos/>  
Quelle(image):  
systemcall image [blog]<https://velog.io/@yanghl98/OS%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9CSystem-Call>

<!-- &nbsp; 1칸 띄어쓰기 -->
<!-- &ensp; 2칸 띄어쓰기 -->
<!-- &emsp; 3칸 띄어쓰기 -->
<!-- <sup>[1)](#footnote_1)</sup>

<div class="notice--info">
<a name="footnote_1">1)</a>블라블라<br>
</div> -->
